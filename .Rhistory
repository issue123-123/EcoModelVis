# 刀切法图保存
output$save_knife <- shiny::downloadHandler(
filename = function() {
paste0("knife_plot_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".tif")
},
content = function(file) {
req(knife_values$plot, knife_values$dpi)
# 创建临时文件路径
temp_file <- tempfile(fileext = ".tif")
# 保存图片
ggplot2::ggsave(
filename = temp_file,
plot = knife_values$plot,
device = "tiff",
dpi = knife_values$dpi,
compression = "lzw",
width = 7,
height = 5,
units = "in"
)
# 复制文件到下载位置
file.copy(temp_file, file)
}
)
# ROC曲线
roc_data <- shiny::eventReactive(input$run_roc, {
req(input$presence_file, input$sample_files, input$bg_files)
tryCatch({
# 1. 读取主要样本文件
presence <- read.csv(input$presence_file$datapath)
# 检查必要列
if (!"Test.or.train" %in% colnames(presence)) {
stop("主要样本文件必须包含 'Test.or.train' 列")
}
# 2. 读取样本预测文件列表
sample_files <- input$sample_files
data_list.pre <- lapply(sample_files$datapath, function(file) {
read.csv(file)
})
# 3. 读取背景预测文件列表
bg_files <- input$bg_files
data_list.bac <- lapply(bg_files$datapath, function(file) {
read.csv(file)
})
# 检查文件数量一致
n_folds <- length(sample_files$name)
if (length(data_list.pre) != n_folds || length(data_list.bac) != n_folds) {
stop(sprintf("文件数量不一致: 样本文件%d个, 背景文件%d个",
length(data_list.pre), length(data_list.bac)))
}
# 合并文件
merged_pre <- do.call(cbind, data_list.pre)
merged_bac <- do.call(cbind, data_list.bac)
# 确定列索引
pre_col_indexes <- seq(6, 6 * n_folds, by = 6)
if (max(pre_col_indexes) > ncol(merged_pre)) {
stop(sprintf("样本文件列数不足。需要至少%d列，实际%d列",
max(pre_col_indexes), ncol(merged_pre)))
}
pre <- merged_pre[, pre_col_indexes, drop = FALSE]
bac_col_indexes <- seq(5, 5 * n_folds, by = 5)
if (max(bac_col_indexes) > ncol(merged_bac)) {
stop(sprintf("背景文件列数不足。需要至少%d列，实际%d列",
max(bac_col_indexes), ncol(merged_bac)))
}
bac <- merged_bac[, bac_col_indexes, drop = FALSE]
# 计算AUC和ROC
auc_list <- numeric(n_folds)
tpr_list <- list()
fpr_list <- list()
for (i in 1:n_folds) {
pp <- pre[, i]
bb <- bac[, i]
# 仅使用训练数据
train_idx <- presence$Test.or.train == "train"
if (sum(train_idx) == 0) {
stop("没有找到训练数据，请检查 'Test.or.train' 列")
}
trainpp <- pp[train_idx]
combined <- c(trainpp, bb)
label <- c(rep(1, length(trainpp)), rep(0, length(bb)))
pred <- ROCR::prediction(combined, label)
perf <- ROCR::performance(pred, "tpr", "fpr")
auc_list[i] <- ROCR::performance(pred, "auc")@y.values[[1]]
tpr_list[[i]] <- perf@x.values[[1]]
fpr_list[[i]] <- perf@y.values[[1]]
}
# 准备绘图数据
tpr.dat <- do.call(cbind, tpr_list)
fpr.dat <- do.call(cbind, fpr_list)
tpr.dat.plot <- data.frame(tpr.mean = rowMeans(tpr.dat))
fpr.dat.plot <- data.frame(
fpr.mean = rowMeans(fpr.dat),
fpr.sd = matrixStats::rowSds(fpr.dat, na.rm = TRUE)
)
data_train <- cbind(tpr.dat.plot, fpr.dat.plot)
n <- nrow(data_train)
# 处理边界值
first_one_index <- which(data_train$fpr.mean == 1)[1]
if (!is.na(first_one_index)) {
data_train[first_one_index:n, 1:2] <- 1
data_train[first_one_index:n, 3] <- 0
}
# 确保auc_list存在
if (length(auc_list) == 0) {
stop("无法计算平均AUC值，auc_list为空")
}
auc_mean <- mean(auc_list, na.rm = TRUE)
# 创建ROC曲线图 - 设置字体为宋体和Times New Roman
roc_plot <- ggplot2::ggplot(data = data_train, ggplot2::aes(x = tpr.mean)) +
# 1. 绘制带状区域（蓝色，不透明）
ggplot2::geom_ribbon(
ggplot2::aes(ymin = fpr.mean - fpr.sd,
ymax = fpr.mean + fpr.sd),
fill = "blue",
alpha = 1,
color = NA
) +
# 2. 绘制均值线（红色）
ggplot2::geom_line(
ggplot2::aes(y = fpr.mean),
color = "red",
size = 0.8
) +
# 3. 绘制随机预测线（黑色实线）
ggplot2::geom_line(
data = data.frame(x = c(0, 1), y = c(0, 1)),
ggplot2::aes(x = x, y = y),
color = "black",
size = 0.8,
linetype = "solid"
) +
# 添加图例映射
ggplot2::geom_point(
data = data.frame(
color = c("red", "blue", "black")
),
ggplot2::aes(x = -Inf, y = -Inf, color = color),
size = 0,
alpha = 0
) +
# 设置图例颜色和形状
ggplot2::scale_color_manual(
name = "",
values = c(
"red" = "red",
"blue" = "blue",
"black" = "black"
),
labels = c(
paste0("Mean (AUC=", round(auc_mean, 3), ")"),
"Random Prediction",
"Mean+/-one std dev"
)
) +
ggplot2::theme_bw() +
ggplot2::scale_x_continuous(
name = input$roc_xlab,
breaks = seq(0, 1, 0.2),
limits = c(0, 1)
) +
ggplot2::scale_y_continuous(
name = input$roc_ylab,
breaks = seq(0, 1, 0.2),
limits = c(0, 1)
) +
ggplot2::labs(title = input$roc_title) +
ggplot2::theme(
text = ggplot2::element_text(family = "win_font"),  # 全局字体
plot.title = ggplot2::element_text(
hjust = 0.5,
size = input$roc_title_size,
family = "win_font"  # 标题使用宋体
),
axis.title.x = ggplot2::element_text(
size = input$roc_xlab_size,
family = "win_font"  # X轴标题使用宋体
),
axis.title.y = ggplot2::element_text(
size = input$roc_ylab_size,
family = "win_font"  # Y轴标题使用宋体
),
axis.text = ggplot2::element_text(size = 12, family = "win_font"),
legend.text = ggplot2::element_text(size = 10, family = "win_font"),  # 图例字体
legend.title = ggplot2::element_blank(),
legend.position = c(0.95, 0.05),
legend.justification = c(1, 0),
legend.direction = "vertical",
legend.key = ggplot2::element_blank(),
legend.key.size = ggplot2::unit(1.5, "lines"),
legend.background = ggplot2::element_blank(),
legend.box.background = ggplot2::element_blank(),
legend.box.margin = ggplot2::margin(2, 2, 2, 2),
panel.grid.major = ggplot2::element_blank(),
panel.grid.minor = ggplot2::element_blank(),
panel.border = ggplot2::element_rect(
colour = "black",
fill = NA,
linewidth = 1,
inherit.blank = FALSE
)
) +
# 恢复图例显示为实心方块（色块）
ggplot2::guides(
color = ggplot2::guide_legend(
override.aes = list(
shape = 15,
size = 4,
alpha = 1
)
)
)
# 对于英文部分，使用Times New Roman
if (grepl("[A-Za-z]", input$roc_title)) {
roc_plot <- roc_plot +
ggplot2::theme(plot.title = ggplot2::element_text(family = "win_font_en"))
}
if (grepl("[A-Za-z]", input$roc_xlab)) {
roc_plot <- roc_plot +
ggplot2::theme(axis.title.x = ggplot2::element_text(family = "win_font_en"))
}
if (grepl("[A-Za-z]", input$roc_ylab)) {
roc_plot <- roc_plot +
ggplot2::theme(axis.title.y = ggplot2::element_text(family = "win_font_en"))
}
return(list(auc = auc_list, plot = roc_plot))
}, error = function(e) {
shiny::showNotification(paste("生成ROC曲线错误:", e$message), type = "error", duration = 10)
NULL
})
})
# 显示ROC曲线
output$roc_plot <- shiny::renderPlot({
data <- roc_data()
if (is.null(data)) return()
data$plot
})
# 显示AUC值
output$auc_text <- shiny::renderPrint({
data <- roc_data()
if (is.null(data)) return()
cat("平均AUC值:", round(mean(data$auc), 3), "\n")
cat("各折AUC值:\n")
print(round(data$auc, 3))
})
# ROC曲线保存
output$save_roc <- shiny::downloadHandler(
filename = function() {
paste0("roc_curve_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".tif")
},
content = function(file) {
data <- roc_data()
if (is.null(data)) return()
# 保存图片
ggplot2::ggsave(
filename = file,
plot = data$plot,
device = "tiff",
dpi = input$roc_dpi,
compression = "lzw",
width = 8,
height = 6,
units = "in"
)
}
)
}
# 运行应用
shiny::shinyApp(ui, server)
}
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
library(devtools)
document()
library(devtools)
document()
build()
library(devtools)
document()
devtools::load_all()
devtools::load_all()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
library(devtools)
document()
build()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
knife_plot <- function(file_path, title = "刀切法", save_plot = FALSE, output_file = NULL) {
# 验证包依赖
required_pkgs <- c("dplyr", "tidyr", "ggplot2", "magrittr", "scales", "readr", "stringr")
check_packages(required_pkgs)
# 读取数据 - 处理BOM
if (!file.exists(file_path)) {
stop("找不到文件: ", file_path)
}
# 尝试读取文件
data <- tryCatch({
read.csv(file_path, fileEncoding = "UTF-8-BOM")
}, error = function(e) {
# 尝试不指定编码读取
tryCatch({
read.csv(file_path)
}, error = function(e2) {
# 尝试使用readr读取
readr::read_csv(file_path)
})
})
# 打印数据预览
message("CSV文件内容预览:")
print(head(data))
# 检查列名
if (!"variable" %in% colnames(data)) {
stop("CSV文件必须包含 'variable' 列")
}
# 数据转换 - 更健壮的列名处理
tryCatch({
# 第一步：将数据从宽格式转换为长格式
long_step1 <- data %>%
tidyr::pivot_longer(
cols = -variable,
names_to = "bio",
values_to = "value"
)
# 第二步：将数据从长格式转换为宽格式，但转置
wide_step <- long_step1 %>%
tidyr::pivot_wider(
names_from = variable,
values_from = value
)
# 第三步：重命名列
# 使用模糊匹配来处理列名变体
col_names <- colnames(wide_step)
without_col <- grep("Without", col_names, value = TRUE, ignore.case = TRUE)
with_only_col <- grep("With.only|With_only", col_names, value = TRUE, ignore.case = TRUE)
if (length(without_col) == 0 || length(with_only_col) == 0) {
stop("无法识别 'Without variable' 和 'With only variable' 列")
}
# 重命名列
wide_step <- wide_step %>%
dplyr::rename(
Without = !!without_col[1],
With_only = !!with_only_col[1]
)
# 第四步：将数据从宽格式转换为长格式
long_data <- wide_step %>%
tidyr::pivot_longer(
cols = c(Without, With_only),
names_to = "category",
values_to = "value"
) %>%
dplyr::mutate(
color_group = dplyr::case_when(
category == "Without" & bio == "With.all.variables" ~ "With.all.variables",
category == "Without" ~ "Without",
TRUE ~ "With_only"
),
position = dplyr::if_else(category == "Without", -0.15, 0.15)
)
}, error = function(e) {
stop("数据处理错误: ", e$message)
})
# === 主要修改点：调整y轴顺序 ===
# 识别"With.all.variables"的变体名称
all_vars <- grep("with.*all", unique(long_data$bio), value = TRUE, ignore.case = TRUE)
if (length(all_vars) == 0) {
stop("无法识别 'With.all.variables' 列")
}
all_var_name <- all_vars[1]
# 获取非"With.all.variables"的变量列表
other_vars <- setdiff(unique(long_data$bio), all_var_name)
# 设置因子水平：其他变量按字母顺序，"With.all.variables"在最后（最上方）
bio_order <- c(sort(other_vars), all_var_name)
long_data$bio <- factor(long_data$bio, levels = bio_order)
# 更新color_group中的名称匹配
long_data <- long_data %>%
dplyr::mutate(
color_group = dplyr::case_when(
category == "Without" & bio == all_var_name ~ "With.all.variables",
TRUE ~ color_group
)
)
# === 修改结束 ===
# 获取最大值用于坐标轴扩展
max_value <- max(long_data$value, na.rm = TRUE)
# 绘图
p <- ggplot2::ggplot(long_data, ggplot2::aes(y = bio, x = value)) +
# 三个geom_col部分保持不变
ggplot2::geom_col(
data = dplyr::filter(long_data, color_group == "Without"),
ggplot2::aes(fill = color_group),
width = 0.7,
position = ggplot2::position_nudge(y = -0.1)
) +
ggplot2::geom_col(
data = dplyr::filter(long_data, color_group == "With.all.variables"),
ggplot2::aes(fill = color_group),
width = 0.7,
position = ggplot2::position_nudge(y = -0.1)
) +
ggplot2::geom_col(
data = dplyr::filter(long_data, color_group == "With_only"),
ggplot2::aes(fill = color_group),
width = 0.7,
position = ggplot2::position_nudge(y = 0.1)
) +
# 图例设置
ggplot2::scale_fill_manual(
values = c(
"Without" = "#00aaaa",        # 青色
"With_only" = "#0000FF",      # 蓝色
"With.all.variables" = "#FF0000"  # 红色
),
breaks = c("With.all.variables", "Without", "With_only"),
labels = c("With all variables", "Without variable", "With only variable")
) +
# 坐标轴设置
ggplot2::scale_x_continuous(
breaks = seq(0, ceiling(max_value), by = 1),
expand = ggplot2::expansion(mult = c(0, 0.05))
) +
# 标签设置
ggplot2::labs(
title = title,
y = "Variable",
x = "Training gain"
) +
# 主题设置
ggplot2::theme_bw() +
ggplot2::theme(
plot.title = ggplot2::element_text(hjust = 0.5),
axis.line = ggplot2::element_line(color = "black", linewidth = 0.5),
axis.ticks = ggplot2::element_line(color = "black", linewidth = 0.5),
axis.ticks.length = ggplot2::unit(-0.15, "cm"),
axis.text = ggplot2::element_text(color = "black"),
axis.text.y = ggplot2::element_text(size = 8),  # 减小y轴标签字号
# 调整y轴标题位置
axis.title.y = ggplot2::element_text(
margin = ggplot2::margin(r = -5, unit = "pt")  # 减少右侧空白
),
panel.grid = ggplot2::element_blank(),
panel.border = ggplot2::element_rect(
colour = "black",
linewidth = 1.2,
fill = NA
),
legend.position = c(1.03, 0.85),
legend.justification = c(0, 0.5),
plot.margin = ggplot2::margin(5, 35, 5, 5, unit = "mm"),
legend.key.size = ggplot2::unit(0.4, "cm"),
legend.text = ggplot2::element_text(size = 8),
legend.spacing = ggplot2::unit(0.2, "cm"),
legend.background = ggplot2::element_blank(),
legend.title = ggplot2::element_blank()
) +
ggplot2::guides(fill = ggplot2::guide_legend(title = NULL))
# 保存图片功能
if (save_plot) {
if (is.null(output_file)) {
stop("当 save_plot=TRUE 时，必须指定 output_file 参数")
}
# 确保输出目录存在
output_dir <- dirname(output_file)
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
}
# 保存为TIFF格式
ggplot2::ggsave(
filename = output_file,
plot = p,
device = "tiff",
dpi = 600,
compression = "lzw",  # 使用LZW压缩减小文件大小
units = "in",        # 使用英寸作为单位
width = 7,           # 默认宽度7英寸
height = 5           # 默认高度5英寸
)
message("图片已保存至: ", normalizePath(output_file))
}
return(p)
}
run_ecovis_app()
devtools::load_all(".")
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
run_ecovis_app()
